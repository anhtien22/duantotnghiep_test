{"ast":null,"code":"/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\nexport var svgPath = function svgPath(points, command) {\n  if (points.length === 0) {\n    return '';\n  }\n  // build the d attributes by looping over the points\n  var d = points.reduce(function (acc, point, i, a) {\n    return i === 0 ?\n    // if first point\n    \"M \".concat(point[0], \",\").concat(point[1]) :\n    // else\n    \"\".concat(acc, \" \").concat(command(point, i, a));\n  }, '');\n  return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\");\n};\n/**\n * @hidden\n *\n * Returns the properties of a line.\n *\n * @param pointA (array) [x,y] Represents the start point coordinates.\n * @param pointB (array) [x,y] Represents the end point coordinates.\n * @output (object) { length: (integer), angle: (integer) }\n */\nexport var line = function line(pointA, pointB) {\n  var lengthX = pointB[0] - pointA[0];\n  var lengthY = pointB[1] - pointA[1];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n/**\n * @hidden\n *\n * Create a function to calculate the position of the control point.\n *\n * @param lineCalc (function) Represents the line function.\n *      @param pointA (array) [x,y] Represents the start point coordinates.\n *      @param pointB (array) [x,y] Represents the end point coordinates.\n *      @output (object) { length: (integer), angle: (integer) }\n * @output (function) closure.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n */\nexport var controlPoint = function controlPoint(lineCalc) {\n  return function (current, previous, next, reverse) {\n    // when 'current' is the first or last point of the array\n    // 'previous' and 'next' are undefined \n    // replace with 'current'\n    var p = previous || current;\n    var n = next || current;\n    var smooth = 0.1;\n    // properties of the line between previous and next \n    var l = lineCalc(p, n);\n    // If is end-control-point, add PI to the angle to go backward\n    var angle = l.angle + (reverse ? Math.PI : 0);\n    var length = l.length * smooth;\n    // The control point position is relative to the current point\n    var x = current[0] + Math.cos(angle) * length;\n    var y = current[1] + Math.sin(angle) * length;\n    return [x, y];\n  };\n};\n/**\n * @hidden\n *\n * Create a function to calculate a bezier curve command.\n *\n * @param controlPointCalc (function) Represents the controlPoint function.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n * @output (function) closure.\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\n */\nexport var bezierCommand = function bezierCommand(controlPointCalc) {\n  return function (point, i, a) {\n    // start control point\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point),\n      cpsX = _a[0],\n      cpsY = _a[1];\n    // end control point\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true),\n      cpeX = _b[0],\n      cpeY = _b[1];\n    return \"C \".concat(cpsX, \",\").concat(cpsY, \" \").concat(cpeX, \",\").concat(cpeY, \" \").concat(point[0], \",\").concat(point[1]);\n  };\n};","map":{"version":3,"names":["svgPath","points","command","length","d","reduce","acc","point","i","a","concat","line","pointA","pointB","lengthX","lengthY","Math","sqrt","pow","angle","atan2","controlPoint","lineCalc","current","previous","next","reverse","p","n","smooth","l","PI","x","cos","y","sin","bezierCommand","controlPointCalc","_a","cpsX","cpsY","_b","cpeX","cpeY"],"sources":["D:/Dự Án Tốt Nghiệp/duantotnghiep_test/frontend/node_modules/@progress/kendo-react-inputs/dist/es/colors/utils/svg-calc.js"],"sourcesContent":["/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\nexport var svgPath = function (points, command) {\n    if (points.length === 0) {\n        return '';\n    }\n    // build the d attributes by looping over the points\n    var d = points.reduce(function (acc, point, i, a) {\n        return i === 0 ?\n            // if first point\n            \"M \".concat(point[0], \",\").concat(point[1]) :\n            // else\n            \"\".concat(acc, \" \").concat(command(point, i, a));\n    }, '');\n    return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\");\n};\n/**\n * @hidden\n *\n * Returns the properties of a line.\n *\n * @param pointA (array) [x,y] Represents the start point coordinates.\n * @param pointB (array) [x,y] Represents the end point coordinates.\n * @output (object) { length: (integer), angle: (integer) }\n */\nexport var line = function (pointA, pointB) {\n    var lengthX = pointB[0] - pointA[0];\n    var lengthY = pointB[1] - pointA[1];\n    return {\n        length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n        angle: Math.atan2(lengthY, lengthX)\n    };\n};\n/**\n * @hidden\n *\n * Create a function to calculate the position of the control point.\n *\n * @param lineCalc (function) Represents the line function.\n *      @param pointA (array) [x,y] Represents the start point coordinates.\n *      @param pointB (array) [x,y] Represents the end point coordinates.\n *      @output (object) { length: (integer), angle: (integer) }\n * @output (function) closure.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n */\nexport var controlPoint = function (lineCalc) {\n    return function (current, previous, next, reverse) {\n        // when 'current' is the first or last point of the array\n        // 'previous' and 'next' are undefined \n        // replace with 'current'\n        var p = previous || current;\n        var n = next || current;\n        var smooth = 0.1;\n        // properties of the line between previous and next \n        var l = lineCalc(p, n);\n        // If is end-control-point, add PI to the angle to go backward\n        var angle = l.angle + (reverse ? Math.PI : 0);\n        var length = l.length * smooth;\n        // The control point position is relative to the current point\n        var x = current[0] + Math.cos(angle) * length;\n        var y = current[1] + Math.sin(angle) * length;\n        return [x, y];\n    };\n};\n/**\n * @hidden\n *\n * Create a function to calculate a bezier curve command.\n *\n * @param controlPointCalc (function) Represents the controlPoint function.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n * @output (function) closure.\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\n */\nexport var bezierCommand = function (controlPointCalc) { return function (point, i, a) {\n    // start control point\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point), cpsX = _a[0], cpsY = _a[1];\n    // end control point\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true), cpeX = _b[0], cpeY = _b[1];\n    return \"C \".concat(cpsX, \",\").concat(cpsY, \" \").concat(cpeX, \",\").concat(cpeY, \" \").concat(point[0], \",\").concat(point[1]);\n}; };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}